// import 'dart:async';
//
// import 'package:d2_remote/modules/datarun/form/shared/rule.dart';
// import 'package:d2_remote/modules/datarun/form/shared/value_type.dart';
// import 'package:flutter/foundation.dart';
// import 'package:mass_pro/data_run/form/form_model/rule_evaluation/rule_evaluation_result.dart';
// import 'package:mass_pro/data_run/utils/get_item_local_string.dart';
// import 'package:mass_pro/form/ui/intent/form_intent.dart';
//
// const _fieldNameDelimiter = '.';
//
// abstract class AbstractFieldModel {
//   final _statusChanges = StreamController<FieldStatus>.broadcast();
//   StreamSubscription<EvaluationResult?>? _asyncRuleEvaluationSubscription;
//
//   AbstractFieldModel({
//     required String name,
//     required String path,
//     bool disabled = true,
//     bool hidden = true,
//     Map<String, String> label = const {},
//     List<Rule> rules = const [],
//     int asyncRuleEvaluatorsDebounceTime = 250,
//     this.valueType,
//     this.order = 0,
//   })  : _name = name,
//         _path = path,
//         _asyncRuleEvaluatorsDebounceTime = asyncRuleEvaluatorsDebounceTime,
//         _status = disabled
//             ? FieldStatus.disabled
//             : hidden
//                 ? FieldStatus.hidden
//                 : FieldStatus.valid {
//     setLabel(label);
//     setRules(rules);
//   }
//
//   String _name;
//   String _path;
//   FieldStatus _status;
//   List<Rule> _rules = <Rule>[];
//   List<EvaluationResult> _evaluationResults = [];
//
//   int order;
//
//   Map<String, String> _label = {};
//
//   /// parent section of this
//   AbstractFieldModel? section;
//
//   /// Section, RepeatedSection, Text, Number, Date ...
//   ValueType? valueType;
//
//   /// Async validators debounce timer.
//   Timer? _debounceTimer;
//
//   /// Async validators debounce time in milliseconds.
//   final int _asyncRuleEvaluatorsDebounceTime;
//
//   /// An object containing any evaluationResults generated by evaluating rules,
//   /// or empty [List] if there are no evaluation results returned.
//   // List<EvaluationResult> get evaluationResults =>
//   //     List.unmodifiable(_evaluationResults);
//
//   /// uniquely identify fields
//   String get name => _name;
//
//   /// path delimited by [_fieldNameDelimiter] from parents to this field
//   String get path => _path;
//
//   /// map of local:label
//   Map<String, String>? get label => Map<String, String>.unmodifiable(_label);
//
//   /// Rules with expression and action, actions
//   /// can include one of (show, error, assign ...)
//   /// expression is evaluated using an expression evaluator
//   /// and the action will be applied
//   List<Rule> get rules => List<Rule>.unmodifiable(_rules);
//
//   /// A [Stream] that emits the status every time it changes.
//   Stream<FieldStatus> get statusChanged => _statusChanges.stream;
//
//   // List<AsyncRuleEvaluator> get asyncRuleEvaluators =>
//   //     List<AsyncRuleEvaluator>.unmodifiable(_asyncRuleEvaluators);
//
//   /// Returns true if all children disabled, otherwise returns false.
//   @protected
//   bool allFieldsDisabled() => disabled;
//
//   /// Returns true if all children disabled, otherwise returns false.
//   @protected
//   bool allFieldsHidden() => hidden;
//
//   void setRules(List<Rule> rules) {
//     clearRules();
//     _rules.addAll(rules);
//   }
//
//   void clearRules() {
//     _rules.clear();
//   }
//
//   void setLabel(Map<String, String> label) {
//     _label.clear();
//     _label.addAll(label);
//   }
//
//   @protected
//   Object? reduceValue();
//
//   void _setInitialStatus() {
//     _status = allFieldsDisabled()
//         ? FieldStatus.disabled
//         : allFieldsHidden()
//             ? FieldStatus.hidden
//             : FieldStatus.valid;
//   }
//
//   /// it will get the label based on local
//   String get formattedLabel => getItemLocalString(label, defaultString: name);
//
//   /// A field is valid when its [status] is FieldStatus.valid.
//   bool get valid => status == FieldStatus.valid;
//
//   /// A field is invalid when its [status] is FieldStatus.invalid.
//   bool get invalid => status == FieldStatus.invalid;
//
//   /// A field is pending when its [status] is FieldStatus.pending.
//   bool get pending => status == FieldStatus.pending;
//
//   /// A field is disabled when its [status] is FieldStatus.disabled.
//   bool get disabled => status == FieldStatus.disabled;
//
//   /// A field is enabled as long as its [status] is
//   /// not FieldStatus.disabled.
//   bool get enabled => !disabled;
//
//   bool get hidden => _status == FieldStatus.hidden;
//
//   bool get visible => _status != FieldStatus.hidden;
//
//   // /// True whether the field has validation errors.
//   // bool get hasErrors => errors.isNotEmpty;
//
//   /// The validation status of the field.
//   ///
//   /// There are four possible validation status values:
//   /// * VALID: This field has passed all validation checks.
//   /// * INVALID: This field has failed at least one validation check.
//   /// * PENDING: This field is in the midst of conducting a validation check.
//   /// * DISABLED: This field is exempt from ancestor calculations of
//   /// * HIDDEN: This field is exempt from ancestor calculations of
//   /// validity or value.
//   ///
//   /// These status values are mutually exclusive, so a field cannot be both
//   /// valid AND invalid or invalid AND pending.
//   FieldStatus get status => _status;
//
//   void markAsEnabled() {
//     if (enabled) {
//       return;
//     }
//     _status = FieldStatus.valid;
//   }
//
//   void markAsHidden() {
//     if (hidden) {
//       return;
//     }
//     _status = FieldStatus.hidden;
//   }
//
//   /// Returns true if all children has the specified [status], otherwise
//   /// returns false.
//   @protected
//   bool anyControlsHaveStatus(FieldStatus status) => false;
//
//   @protected
//   void forEachChild(void Function(AbstractFieldModel) callback);
//
//   @protected
//   bool anyControls(bool Function(AbstractFieldModel) condition);
//
//   @protected
//   AbstractFieldModel? findField(String path);
//
//   /// Disposes the control
//   void dispose() {
//     _statusChanges.close();
//     _asyncRuleEvaluationSubscription?.cancel();
//   }
// }
//
// // this is much like formGroup and formArray parent abstract class and would be mapped to it
// abstract class AbstractSectionModel extends AbstractFieldModel {
//   AbstractSectionModel(
//     Map<String, AbstractFieldModel> fields, {
//     required String uid,
//     required String path,
//     this.isOpen = false,
//     Map<String, String> label = const {},
//     bool isEditable = true,
//     bool isVisible = true,
//     List<Rule> rules = const [],
//     ValueType? valueType,
//     int order = 0,
//   })  : assert(!fields.keys.any((name) => name.contains(_fieldNameDelimiter)),
//             'Field name should not contain dot($_fieldNameDelimiter)'),
//         super(
//           name: uid,
//           path: path,
//           label: label,
//           disabled: isEditable,
//           hidden: isVisible,
//           rules: rules,
//           valueType: valueType,
//           order: order,
//         ) {
//     addAll(fields);
//   }
//
//   final Map<String, AbstractFieldModel> _fields = {};
//
//   bool isOpen;
//
//   int get totalFields => 0; // implement calculating from fields
//   int get completedFields => 0; // implement calculating from fields
//   /// Retrieves a child field given the field's [name] or path.
//   ///
//   /// The [name] is a dot-delimited string that define the path to the
//   /// field.
//   ///
//   /// Throws [FieldModelNotFoundException] if no field founded with
//   /// the specified [name]/path.
//   AbstractFieldModel field(String name);
//
//   /// Checks if section contains a field by a given [name].
//   ///
//   /// Returns true if section contains the field, otherwise returns false.
//   bool contains(String name);
//
//   /// Walks the [path] to find the matching field.
//   ///
//   /// Returns null if no match is found.
//   AbstractFieldModel? findFieldInSection(List<String> path) {
//     if (path.isEmpty) {
//       return null;
//     }
//
//     final result = path.fold<AbstractFieldModel?>(this, (field, name) {
//       if (field != null && field is AbstractSectionModel) {
//         return field.contains(name) ? field.field(name) : null;
//       } else {
//         return null;
//       }
//     });
//
//     return result;
//   }
//
//   /// Appends all [fields] to the group.
//   void addAll(Map<String, AbstractFieldModel> fields) {
//     _fields.addAll(fields);
//     fields.forEach((name, field) {
//       field.section = this;
//     });
//   }
// }
//
// typedef IntentCallback = void Function(FormIntent intent);
//
// // this is much like formField and would be mapped to it
// class QFieldModel extends AbstractFieldModel {
//   QFieldModel(
//       {required String uid,
//       required String path,
//       Map<String, String> label = const {},
//       bool isEditable = true,
//       bool isVisible = true,
//       List<Rule> rules = const [],
//       String? displayName,
//       String? section,
//       String? description,
//       ValueType? valueType,
//       int order = 0,
//       this.defaultValue,
//       this.value,
//       this.isMandatory = false,
//       this.listName,
//       this.intentCallback})
//       : super(
//           name: uid,
//           path: path,
//           label: label,
//           disabled: isEditable,
//           hidden: isVisible,
//           rules: rules,
//           valueType: valueType,
//           order: order,
//         );
//
//   final String? defaultValue;
//   final String? value;
//   final bool isMandatory;
//   final String? listName;
//   final IntentCallback? intentCallback;
//
//   @override
//   void forEachChild(void Function(AbstractFieldModel) callback) =>
//       <AbstractFieldModel>[];
//
//   @override
//   bool anyControls(bool Function(AbstractFieldModel) condition) => false;
//
//   @override
//   AbstractFieldModel findField(String path) => this;
//
//   @override
//   String get formattedLabel =>
//       isMandatory ? '${super.formattedLabel} *' : super.formattedLabel;
//
//   @override
//   void _updateValue() {
//     // TODO: implement _updateValue
//   }
//
//   @override
//   Object? reduceValue() => value;
// }
//
// enum SectionRenderingType { Listing, Sequential, Matrix }
//
// /// Enums that represents the different
// /// validation status of an [AbstractField]
// ///
// /// See [AbstractField.status]
// enum FieldStatus {
//   /// The field is in the midst of conducting a validation check.
//   pending,
//
//   /// The field has passed all validation checks.
//   valid,
//
//   /// The field has failed at least one validation check.
//   invalid,
//
//   /// This field is exempt from validation checks.
//   disabled,
//
//   /// This field is exempt from validation checks.
//   hidden,
// }
